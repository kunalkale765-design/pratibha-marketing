{"version":3,"file":"ui-DPXrEiII.js","sources":["../../src/js/csrf.js","../../src/js/auth.js","../../src/js/ui.js"],"sourcesContent":["/**\n * CSRF Token Management Module\n * Single source of truth for CSRF token handling\n *\n * This module is imported by both auth.js and api.js to avoid code duplication.\n */\n\n// Track if we're currently refreshing to avoid concurrent requests\nlet csrfRefreshPromise = null;\n\n/**\n * Get CSRF token from cookie\n * @returns {string|null}\n */\nexport function getCsrfToken() {\n    const match = document.cookie.match(/csrf_token=([^;]+)/);\n    return match ? match[1] : null;\n}\n\n/**\n * Fetch a fresh CSRF token from the server\n * Deduplicates concurrent refresh requests\n * @returns {Promise<string|null>}\n */\nexport async function refreshCsrfToken() {\n    // If already refreshing, wait for that promise\n    if (csrfRefreshPromise) {\n        return csrfRefreshPromise;\n    }\n\n    csrfRefreshPromise = (async () => {\n        const controller = new AbortController();\n        const timeout = setTimeout(() => controller.abort(), 5000);\n        try {\n            const response = await fetch('/api/csrf-token', {\n                credentials: 'include',\n                signal: controller.signal\n            });\n            if (response.ok) {\n                const data = await response.json();\n                // The cookie is set by the server, but we return the token too\n                return data.csrfToken || getCsrfToken();\n            }\n        } catch (error) {\n            if (error.name !== 'AbortError') {\n                console.error('Failed to refresh CSRF token:', error);\n            }\n        } finally {\n            clearTimeout(timeout);\n        }\n        return null;\n    })();\n\n    try {\n        return await csrfRefreshPromise;\n    } finally {\n        csrfRefreshPromise = null;\n    }\n}\n\n/**\n * Ensure CSRF token is available, fetching if necessary\n * @returns {Promise<string|null>}\n */\nexport async function ensureCsrfToken() {\n    let token = getCsrfToken();\n    if (!token) {\n        token = await refreshCsrfToken();\n    }\n    return token;\n}\n","/**\n * Authentication Module for Pratibha Marketing\n * Handles login state, token management, and auth redirects\n */\n\n// Import CSRF functions from shared module (single source of truth)\nimport { getCsrfToken, refreshCsrfToken, ensureCsrfToken } from './csrf.js';\n\nconst Auth = {\n    // Storage keys\n    USER_KEY: 'user',\n\n    // Re-export CSRF functions for backwards compatibility\n    getCsrfToken,\n    refreshCsrfToken,\n    ensureCsrfToken,\n\n    /**\n     * Check if user is logged in\n     * @returns {boolean}\n     */\n    isLoggedIn() {\n        return !!this.getUser();\n    },\n\n    /**\n     * Get stored user data\n     * @returns {Object|null}\n     */\n    getUser() {\n        try {\n            const user = localStorage.getItem(this.USER_KEY);\n            return user ? JSON.parse(user) : null;\n        } catch (e) {\n            console.error('Error parsing user data:', e);\n            return null;\n        }\n    },\n\n    /**\n     * Store user data after login\n     * Only stores essential fields to minimize exposure in localStorage\n     * SECURITY: Never store prices in localStorage - customers should not see pricing\n     * @param {Object} user\n     */\n    setUser(user) {\n        // Only store essential data - exclude sensitive info\n        // For contract customers, store only allowed product IDs (not prices)\n        // Prices are calculated server-side; customers should never see them\n        const safeUser = {\n            id: user.id,\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            customer: user.customer ? {\n                _id: user.customer._id,\n                name: user.customer.name,\n                pricingType: user.customer.pricingType,\n                // Use allowedProducts from backend (IDs only, no prices)\n                ...(user.customer.allowedProducts\n                    ? { allowedProducts: user.customer.allowedProducts }\n                    : {})\n            } : null,\n            isMagicLink: user.isMagicLink || false\n        };\n        localStorage.setItem(this.USER_KEY, JSON.stringify(safeUser));\n    },\n\n    /**\n     * Clear all auth data (logout) and purge service worker cache\n     */\n    clearAuth() {\n        localStorage.removeItem(this.USER_KEY);\n        // Notify service worker to purge cached pages (prevents cross-user data leaks)\n        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\n            navigator.serviceWorker.controller.postMessage('logout');\n        }\n        // Also clear caches directly as a fallback (SW message may not be processed before redirect)\n        if ('caches' in window) {\n            caches.keys().then(names => names.forEach(name => caches.delete(name)))\n                .catch(() => {});\n        }\n    },\n\n    /**\n     * Get user role\n     * @returns {string|null}\n     */\n    getRole() {\n        const user = this.getUser();\n        return user ? user.role : null;\n    },\n\n    /**\n     * Check if user has admin or staff role\n     * @returns {boolean}\n     */\n    isStaff() {\n        const role = this.getRole();\n        return role === 'admin' || role === 'staff';\n    },\n\n    /**\n     * Check if user is a customer\n     * @returns {boolean}\n     */\n    isCustomer() {\n        return this.getRole() === 'customer';\n    },\n\n    /**\n     * Verify authentication with server\n     * @returns {Promise<Object|null>}\n     */\n    async verify() {\n        try {\n            const response = await fetch('/api/auth/me', {\n                credentials: 'include'\n            });\n            if (response.ok) {\n                const data = await response.json();\n                this.setUser(data.user);\n                return data.user;\n            } else {\n                // Server responded with auth error - clear local auth\n                this.clearAuth();\n                return null;\n            }\n        } catch (error) {\n            console.error('Auth verification failed:', error);\n            // Only use cached user if truly offline\n            if (!navigator.onLine) {\n                console.warn('Offline - using cached user');\n                return this.getUser();\n            }\n            // Any other error (network timeout, server down, etc.) - clear auth\n            this.clearAuth();\n            return null;\n        }\n    },\n\n    /**\n     * Login user\n     * @param {string} email\n     * @param {string} password\n     * @param {boolean} _isRetry - Internal flag for CSRF retry\n     * @returns {Promise<{success: boolean, user?: Object, error?: string}>}\n     */\n    async login(email, password, _isRetry = false) {\n        try {\n            const headers = { 'Content-Type': 'application/json' };\n            // Ensure we have a CSRF token before login\n            const csrfToken = await this.ensureCsrfToken();\n            if (csrfToken) {\n                headers['X-CSRF-Token'] = csrfToken;\n            }\n\n            const response = await fetch('/api/auth/login', {\n                method: 'POST',\n                headers,\n                credentials: 'include',\n                body: JSON.stringify({ email, password })\n            });\n\n            const data = await response.json();\n\n            if (response.ok) {\n                this.setUser(data.user);\n                return { success: true, user: data.user };\n            }\n\n            // Check if CSRF error and retry once\n            if (response.status === 403 && data?.message?.toLowerCase().includes('csrf') && !_isRetry) {\n                console.log('CSRF token error during login, refreshing and retrying...');\n                await this.refreshCsrfToken();\n                return this.login(email, password, true);\n            }\n\n            return { success: false, error: data.message || 'Login failed' };\n        } catch (error) {\n            console.error('Login error:', error);\n            return { success: false, error: 'Network error. Please try again.' };\n        }\n    },\n\n    /**\n     * Logout user\n     * @returns {Promise<void>}\n     */\n    async logout() {\n        try {\n            const headers = {};\n            // Ensure we have a CSRF token before logout\n            const csrfToken = await this.ensureCsrfToken();\n            if (csrfToken) {\n                headers['X-CSRF-Token'] = csrfToken;\n            }\n\n            const response = await fetch('/api/auth/logout', {\n                method: 'POST',\n                headers,\n                credentials: 'include'\n            });\n            if (!response.ok) {\n                console.warn('Server-side logout returned error:', response.status);\n            }\n        } catch (error) {\n            console.error('Logout error:', error);\n            // Warn about potential server session remaining active\n            console.warn('Server-side session may still be active due to:', error.message);\n        } finally {\n            // Always clear local auth and redirect regardless of server response\n            this.clearAuth();\n            window.location.href = '/pages/auth/login.html';\n        }\n    },\n\n    /**\n     * Require authentication - redirects to login if not authenticated\n     * @param {Array<string>} allowedRoles - Optional: roles allowed to access\n     * @returns {Promise<Object|null>}\n     */\n    async requireAuth(allowedRoles = null) {\n        const user = await this.verify();\n\n        if (!user) {\n            window.location.href = '/pages/auth/login.html';\n            return null;\n        }\n\n        if (allowedRoles && !allowedRoles.includes(user.role)) {\n            // Redirect based on role\n            if (user.role === 'customer') {\n                window.location.href = '/pages/order-form/';\n            } else if (user.role === 'staff') {\n                window.location.href = '/pages/staff-dashboard/';\n            } else {\n                window.location.href = '/';\n            }\n            return null;\n        }\n\n        return user;\n    },\n\n    /**\n     * Redirect if already logged in\n     * @returns {Promise<boolean>} - true if redirected\n     */\n    async redirectIfLoggedIn() {\n        const user = await this.verify();\n        if (user) {\n            if (user.role === 'customer') {\n                window.location.href = '/pages/order-form/';\n            } else if (user.role === 'staff') {\n                window.location.href = '/pages/staff-dashboard/';\n            } else {\n                window.location.href = '/';\n            }\n            return true;\n        }\n        return false;\n    }\n};\n\n// Make Auth globally available for browser use\nif (typeof window !== 'undefined') {\n    window.Auth = Auth;\n}\n\n// Export for use in other modules\nexport default Auth;\n\n","/**\n * UI Components & Interactions\n *\n * Functions for common UI patterns:\n * - Toast notifications\n * - Modals\n * - Password visibility toggle\n * - Loading states\n */\n\n/* ===================\n   DOM HELPERS\n   =================== */\n\n/**\n * Create an element with safe text content and attributes\n * @param {string} tag - HTML tag (e.g., 'div', 'span')\n * @param {Object} attributes - Key-value pairs for attributes (e.g., { class: 'btn', id: 'myBtn' })\n * @param {string|Array<HTMLElement|string>} children - Text content or array of children elements/text\n * @returns {HTMLElement} - The created element\n */\nexport function createElement(tag, attributes = {}, children = []) {\n  const element = document.createElement(tag);\n\n  // Set attributes\n  if (attributes) {\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (key === 'className' || key === 'class') {\n        element.className = value;\n      } else if (key === 'style' && typeof value === 'object') {\n        Object.assign(element.style, value);\n      } else if (key === 'dataset' && typeof value === 'object') {\n        Object.assign(element.dataset, value);\n      } else if (key.startsWith('on') && typeof value === 'function') {\n        // Event listeners (e.g., onclick)\n        element.addEventListener(key.substring(2).toLowerCase(), value);\n      } else {\n        element.setAttribute(key, value);\n      }\n    });\n  }\n\n  // Set content/children\n  if (children) {\n    if (!Array.isArray(children)) {\n      children = [children];\n    }\n\n    children.forEach(child => {\n      if (child instanceof Node) {\n        element.appendChild(child);\n      } else if (child !== null && child !== undefined) {\n        // Treat strings/numbers as text content (safe from XSS)\n        element.appendChild(document.createTextNode(String(child)));\n      }\n    });\n  }\n\n  return element;\n}\n\n/* ===================\n   TOAST NOTIFICATIONS\n   =================== */\n\n/**\n * Show a toast notification\n *\n * @param {string} message - Message to display\n * @param {string} type - 'success', 'error', 'warning', 'info'\n * @param {number} duration - How long to show (ms)\n *\n * @example\n * showToast('Order created!', 'success');\n * showToast('Something went wrong', 'error', 5000);\n */\nexport function showToast(message, type = 'success', duration = 3000) {\n  // Get or create toast element\n  let toast = document.getElementById('toast');\n  if (!toast) {\n    toast = document.createElement('div');\n    toast.id = 'toast';\n    toast.className = 'toast';\n    document.body.appendChild(toast);\n  }\n\n  // Clear any existing timeout (stored on element to avoid module-level state conflicts)\n  if (toast._hideTimeout) {\n    clearTimeout(toast._hideTimeout);\n    toast._hideTimeout = null;\n  }\n\n  // Remove existing type classes\n  toast.classList.remove('toast-success', 'toast-error', 'toast-warning', 'toast-info', 'show');\n\n  // Set message and type\n  toast.textContent = message;\n  toast.classList.add(`toast-${type}`);\n\n  // Show toast\n  requestAnimationFrame(() => {\n    toast.classList.add('show');\n  });\n\n  // Auto-hide after duration\n  toast._hideTimeout = setTimeout(() => {\n    hideToast();\n  }, duration);\n}\n\n/**\n * Hide the toast notification\n */\nexport function hideToast() {\n  const toast = document.getElementById('toast');\n  if (toast) {\n    toast.classList.remove('show');\n  }\n}\n\n/**\n * Show a success toast (shortcut)\n */\nexport function showSuccess(message, duration = 3000) {\n  showToast(message, 'success', duration);\n}\n\n/**\n * Show an info toast for issues (soft notification instead of error)\n */\nexport function showError(message, duration = 4000) {\n  showToast(message, 'info', duration);\n}\n\n/**\n * Show a warning toast (shortcut)\n */\nexport function showWarning(message, duration = 3500) {\n  showToast(message, 'warning', duration);\n}\n\n/* ===================\n   MODAL MANAGEMENT\n   =================== */\n\n/**\n * Open a modal\n *\n * @param {string} modalId - ID of the modal overlay element\n *\n * @example\n * openModal('order-modal');\n */\nexport function openModal(modalId) {\n  const modal = document.getElementById(modalId);\n  if (modal) {\n    modal.classList.add('show');\n    document.body.style.overflow = 'hidden'; // Prevent background scrolling\n  }\n}\n\n/**\n * Close a modal\n *\n * @param {string} modalId - ID of the modal overlay element\n */\nexport function closeModal(modalId) {\n  const modal = document.getElementById(modalId);\n  if (modal) {\n    modal.classList.remove('show');\n    document.body.style.overflow = ''; // Restore scrolling\n  }\n}\n\n/**\n * Close modal when clicking overlay (outside the modal content)\n * Call this once during page init\n *\n * @param {string} modalId - ID of the modal overlay element\n */\nexport function setupModalCloseOnOverlay(modalId) {\n  const modal = document.getElementById(modalId);\n  if (modal) {\n    modal.addEventListener('click', (e) => {\n      if (e.target === modal) {\n        closeModal(modalId);\n      }\n    });\n  }\n}\n\n/**\n * Close modal on Escape key\n * Call this once during page init (idempotent - safe to call multiple times)\n */\nlet _escapeListenerRegistered = false;\nexport function setupModalCloseOnEscape() {\n  if (_escapeListenerRegistered) return;\n  _escapeListenerRegistered = true;\n\n  document.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') {\n      const openModals = document.querySelectorAll('.modal-overlay.show');\n      if (openModals.length === 0) return;\n      // Use page's closeModal if available (handles unsaved changes warnings)\n      if (typeof window.closeModal === 'function') {\n        window.closeModal();\n      } else {\n        openModals.forEach(modal => {\n          modal.classList.remove('show');\n        });\n        document.body.style.overflow = '';\n      }\n    }\n  });\n}\n\n/* ===================\n   PASSWORD VISIBILITY\n   =================== */\n\n/**\n * Toggle password visibility\n *\n * @param {string} inputId - ID of the password input\n * @param {HTMLElement} buttonEl - The toggle button element\n */\nexport function togglePassword(inputId, buttonEl) {\n  const input = document.getElementById(inputId);\n  if (!input) return;\n\n  if (input.type === 'password') {\n    input.type = 'text';\n    if (buttonEl) buttonEl.textContent = '○';\n  } else {\n    input.type = 'password';\n    if (buttonEl) buttonEl.textContent = '◉';\n  }\n}\n\n/* ===================\n   LOADING STATES\n   =================== */\n\n/**\n * Set a button to loading state\n *\n * @param {HTMLElement} button - Button element\n * @param {boolean} loading - Whether to show loading state\n * @param {string} loadingText - Text to show while loading\n */\nexport function setButtonLoading(button, loading = true, loadingText = 'Loading...') {\n  if (!button) return;\n\n  if (loading) {\n    button.dataset.originalText = button.textContent;\n    button.textContent = loadingText;\n    button.disabled = true;\n  } else {\n    button.textContent = button.dataset.originalText || 'Submit';\n    button.disabled = false;\n  }\n}\n\n/* ===================\n   FORM HELPERS\n   =================== */\n\n/**\n * Clear all form inputs\n *\n * @param {HTMLFormElement|string} form - Form element or ID\n */\nexport function clearForm(form) {\n  const formEl = typeof form === 'string' ? document.getElementById(form) : form;\n  if (formEl) {\n    formEl.reset();\n  }\n}\n\n/**\n * Get form data as an object\n *\n * @param {HTMLFormElement|string} form - Form element or ID\n * @returns {Object} - Form data as key-value pairs\n */\nexport function getFormData(form) {\n  const formEl = typeof form === 'string' ? document.getElementById(form) : form;\n  if (!formEl) return {};\n\n  const formData = new FormData(formEl);\n  const data = {};\n  for (const [key, value] of formData) {\n    data[key] = value;\n  }\n  return data;\n}\n\n/* ===================\n   SCROLL HELPERS\n   =================== */\n\n/**\n * Scroll to top of page smoothly\n */\nexport function scrollToTop() {\n  window.scrollTo({ top: 0, behavior: 'smooth' });\n}\n\n/**\n * Scroll to an element\n *\n * @param {string|HTMLElement} element - Element or selector\n */\nexport function scrollToElement(element) {\n  const el = typeof element === 'string' ? document.querySelector(element) : element;\n  if (el) {\n    el.scrollIntoView({ behavior: 'smooth', block: 'start' });\n  }\n}\n\n/* ===================\n   CONFIRMATION DIALOG\n   =================== */\n\n/**\n * Show a confirmation dialog\n *\n * @param {string} message - Confirmation message\n * @returns {boolean} - True if confirmed\n */\nexport function confirm(message) {\n  return window.confirm(message);\n}\n\n/* ===================\n   COPY TO CLIPBOARD\n   =================== */\n\n/**\n * Copy text to clipboard\n *\n * @param {string} text - Text to copy\n * @returns {Promise<boolean>} - True if successful\n */\nexport async function copyToClipboard(text) {\n  try {\n    await navigator.clipboard.writeText(text);\n    showSuccess('Copied to clipboard!');\n    return true;\n  } catch (e) {\n    console.debug('Clipboard copy failed:', e.message);\n    showToast('Could not copy to clipboard', 'info');\n    return false;\n  }\n}\n"],"names":["csrfRefreshPromise","getCsrfToken","match","refreshCsrfToken","controller","timeout","response","error","ensureCsrfToken","token","Auth","user","safeUser","names","name","role","data","email","password","_isRetry","headers","csrfToken","allowedRoles","createElement","tag","attributes","children","element","key","value","child","showToast","message","type","duration","toast","hideToast","showSuccess","_escapeListenerRegistered","setupModalCloseOnEscape","openModals","modal","togglePassword","inputId","buttonEl","input"],"mappings":"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"}