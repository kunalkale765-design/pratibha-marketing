{"version":3,"mappings":"knCASA,IAAIA,EAAS,KACTC,EAAc,GAElB,GAAI,CAGAD,EADY,MAAAE,EAAA,IAAM,OAAO,qBAAiB,MAG1C,MAAMC,EAAM,kGAERA,IACAH,EAAO,KAAK,CACR,IAAKG,EACL,YAAa,aACb,WAAY,EACZ,eAAgB,GAChB,WAAWC,EAAO,CAMd,GAJIA,EAAM,MACN,OAAOA,EAAM,KAAK,WAGlBA,EAAM,SAAS,IACf,GAAI,CACA,MAAMC,EAAM,IAAI,IAAID,EAAM,QAAQ,GAAG,EACrCC,EAAI,aAAa,OAAO,OAAO,EAC/BA,EAAI,aAAa,OAAO,OAAO,EAC/BD,EAAM,QAAQ,IAAMC,EAAI,UAC5B,MAAY,CAA4B,CAE5C,OAAOD,CACX,EACH,EACDH,EAAc,GAEtB,MAAY,CAEZ,CAMO,SAASK,EAAcC,EAAM,CAC3BN,GACLD,EAAO,QAAQO,EAAO,CAAE,GAAIA,EAAK,KAAOA,EAAK,GAAI,KAAMA,EAAK,MAAS,IAAI,CAC7E,CAKO,SAASC,EAAiBC,EAAOC,EAAS,CAC7C,GAAI,CAACT,EAAa,CACd,QAAQ,MAAM,oBAAqBQ,CAAK,EACxC,MACJ,CACAT,EAAO,iBAAiBS,EAAOC,EAAU,CAAE,MAAOA,CAAA,EAAY,MAAS,CAC3E,CCiQA,OAAO,iBAAiB,SAAU,IAAM,CACpC,QAAQ,IAAI,qBAAqB,EACjCC,EAAY,qBAAqB,CACrC,CAAC,EAED,OAAO,iBAAiB,UAAW,IAAM,CACrC,QAAQ,IAAI,iBAAiB,EAC7BC,EAAU,yBAA0B,MAAM,CAC9C,CAAC","names":["Sentry","initialized","__vitePreload","DSN","event","url","setSentryUser","user","captureException","error","context","showSuccess","showToast"],"ignoreList":[],"sources":["../../src/js/sentry.js","../../src/js/api.js"],"sourcesContent":["/**\n * Sentry Browser Integration\n * Initializes error monitoring for the frontend.\n * DSN is injected by Vite at build time via __SENTRY_DSN__.\n *\n * When served without a bundler (e.g., Express static), the @sentry/browser\n * import will fail. We catch this gracefully and export no-op stubs.\n */\n\nlet Sentry = null;\nlet initialized = false;\n\ntry {\n    // Dynamic import so the module doesn't crash when served without a bundler\n    const mod = await import('@sentry/browser');\n    Sentry = mod;\n\n    const DSN = import.meta.env?.VITE_SENTRY_DSN || '';\n\n    if (DSN) {\n        Sentry.init({\n            dsn: DSN,\n            environment: import.meta.env?.MODE || 'production',\n            sampleRate: 1.0,\n            maxBreadcrumbs: 50,\n            beforeSend(event) {\n                // Scrub PII from user context\n                if (event.user) {\n                    delete event.user.ip_address;\n                }\n                // Strip query params that might contain tokens\n                if (event.request?.url) {\n                    try {\n                        const url = new URL(event.request.url);\n                        url.searchParams.delete('token');\n                        url.searchParams.delete('magic');\n                        event.request.url = url.toString();\n                    } catch (_) { /* ignore invalid URLs */ }\n                }\n                return event;\n            }\n        });\n        initialized = true;\n    }\n} catch (_) {\n    // @sentry/browser not available (not bundled) â€” run without Sentry\n}\n\n/**\n * Set user context for Sentry events.\n * Call after successful auth check.\n */\nexport function setSentryUser(user) {\n    if (!initialized) return;\n    Sentry.setUser(user ? { id: user._id || user.id, role: user.role } : null);\n}\n\n/**\n * Capture an exception with optional extra context.\n */\nexport function captureException(error, context) {\n    if (!initialized) {\n        console.error('[Sentry disabled]', error);\n        return;\n    }\n    Sentry.captureException(error, context ? { extra: context } : undefined);\n}\n\n/**\n * Add a breadcrumb for debugging context.\n */\nexport function addBreadcrumb(message, category, data) {\n    if (!initialized) return;\n    Sentry.addBreadcrumb({ message, category, data, level: 'info' });\n}\n\nexport { initialized as sentryEnabled };\n","/**\n * API Module for Pratibha Marketing\n * Centralized fetch wrapper with error handling and offline detection\n */\n\n// Import CSRF functions from shared module (single source of truth)\nimport { getCsrfToken, refreshCsrfToken, ensureCsrfToken } from './csrf.js';\nimport { showToast, showSuccess } from './ui.js';\nimport { captureException, addBreadcrumb } from './sentry.js';\n\nconst API = {\n    // Re-export CSRF functions for backwards compatibility\n    getCsrfToken,\n    refreshCsrfToken,\n    ensureCsrfToken,\n\n    /**\n     * Make an API request with automatic retry for network failures\n     * @param {string} endpoint - API endpoint (e.g., '/api/products')\n     * @param {Object} options - Fetch options\n     * @param {boolean} _isRetry - Internal flag to prevent infinite retry loops\n     * @param {number} _retryCount - Internal counter for network retries\n     * @returns {Promise<{success: boolean, data?: any, error?: string, status?: number}>}\n     */\n    async request(endpoint, options = {}, _isRetry = false, _retryCount = 0) {\n        const MAX_RETRIES = 2;\n        const RETRY_DELAY = 1000; // 1 second\n        const REQUEST_TIMEOUT = 30000; // 30 seconds timeout\n        // Default options\n        const defaultOptions = {\n            credentials: 'include',\n            headers: {\n                'Content-Type': 'application/json',\n                ...options.headers\n            }\n        };\n\n        const fetchOptions = { ...defaultOptions, ...options };\n\n        // Add CSRF token for state-changing requests\n        const stateChangingMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];\n        const isStateChanging = stateChangingMethods.includes(options.method?.toUpperCase());\n\n        if (isStateChanging) {\n            // Ensure we have a CSRF token before making state-changing requests\n            const csrfToken = await this.ensureCsrfToken();\n            if (csrfToken) {\n                fetchOptions.headers['X-CSRF-Token'] = csrfToken;\n            }\n        }\n\n        // Don't set Content-Type for FormData\n        if (options.body instanceof FormData) {\n            delete fetchOptions.headers['Content-Type'];\n        }\n\n        try {\n            // Check if online\n            if (!navigator.onLine) {\n                return {\n                    success: false,\n                    error: 'No internet connection. Please check your network.',\n                    offline: true\n                };\n            }\n\n            // Add breadcrumb for API call tracking\n            addBreadcrumb(`${options.method || 'GET'} ${endpoint}`, 'api');\n\n            // Create abort controller for timeout\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);\n            fetchOptions.signal = controller.signal;\n\n            let response;\n            try {\n                response = await fetch(endpoint, fetchOptions);\n            } finally {\n                clearTimeout(timeoutId);\n            }\n            let data;\n            try {\n                data = await response.json();\n            } catch (parseError) {\n                console.error('API response parse error:', parseError, 'Status:', response.status);\n                // If we can't parse the response, return a helpful error\n                return {\n                    success: false,\n                    error: response.ok\n                        ? 'Server returned an invalid response. Please try again.'\n                        : `Server error (${response.status}). Please try again later.`,\n                    status: response.status,\n                    parseError: true\n                };\n            }\n\n            if (response.ok) {\n                return { success: true, data, status: response.status };\n            }\n\n            // Handle specific error codes\n            if (response.status === 401) {\n                // Unauthorized - clear auth and redirect (singleton guard prevents flicker)\n                if (!API._redirecting401) {\n                    API._redirecting401 = true;\n                    if (typeof Auth !== 'undefined') {\n                        Auth.clearAuth();\n                    }\n                    window.location.href = '/pages/auth/login.html';\n                }\n                return { success: false, error: 'Session expired. Please login again.', status: 401 };\n            }\n\n            if (response.status === 403) {\n                // Check if this is a CSRF error and retry once\n                const isCsrfError = data?.message?.toLowerCase().includes('csrf');\n                if (isCsrfError && !_isRetry && isStateChanging) {\n                    console.log('CSRF token error, refreshing and retrying...');\n                    await this.refreshCsrfToken();\n                    return this.request(endpoint, options, true);\n                }\n                return { success: false, error: data?.message || 'Access denied. You do not have permission.', status: 403 };\n            }\n\n            if (response.status === 404) {\n                return { success: false, error: 'Resource not found.', status: 404 };\n            }\n\n            if (response.status === 429) {\n                return { success: false, error: 'Too many requests. Please try again later.', status: 429 };\n            }\n\n            if (response.status === 408) {\n                return { success: false, error: 'Request timed out. Please try again.', status: 408 };\n            }\n\n            if (response.status === 500) {\n                captureException(new Error(`API 500: ${endpoint}`), { endpoint, method: options.method, responseBody: data });\n                return { success: false, error: data?.message || 'Server error. Please try again later.', status: 500 };\n            }\n\n            if (response.status === 502 || response.status === 503 || response.status === 504) {\n                captureException(new Error(`API ${response.status}: ${endpoint}`), { endpoint, method: options.method, status: response.status });\n                return { success: false, error: 'Service temporarily unavailable. Please try again later.', status: response.status };\n            }\n\n            if (response.status === 422) {\n                // Unprocessable entity - validation errors\n                return {\n                    success: false,\n                    error: data?.message || 'Invalid data provided. Please check your input.',\n                    errors: data?.errors,\n                    status: 422\n                };\n            }\n\n            // Generic error\n            const errorMessage = data?.message || data?.error || 'Something went wrong';\n            return { success: false, error: errorMessage, status: response.status, data };\n\n        } catch (error) {\n            console.error('API request failed:', error);\n\n            // Don't retry if offline\n            if (!navigator.onLine) {\n                return {\n                    success: false,\n                    error: 'No internet connection.',\n                    offline: true\n                };\n            }\n\n            // Don't retry aborted/timeout requests\n            if (error.name === 'AbortError') {\n                captureException(error, { endpoint, method: options.method, type: 'timeout' });\n                return {\n                    success: false,\n                    error: 'Request timed out. Please try again.',\n                    timeout: true,\n                    networkError: true\n                };\n            }\n\n            // Auto-retry for network errors (up to MAX_RETRIES times)\n            if (_retryCount < MAX_RETRIES) {\n                console.log(`Network error, retrying (${_retryCount + 1}/${MAX_RETRIES})...`);\n                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (_retryCount + 1)));\n                return this.request(endpoint, options, _isRetry, _retryCount + 1);\n            }\n\n            // All retries exhausted\n            captureException(error, { endpoint, method: options.method, type: 'network', retries: MAX_RETRIES });\n\n            // Return error silently for GET requests\n            // For state-changing requests, we need to inform the user\n            const isGet = !options.method || options.method.toUpperCase() === 'GET';\n            if (isGet) {\n                return {\n                    success: false,\n                    error: '',\n                    networkError: true,\n                    silent: true\n                };\n            }\n\n            return {\n                success: false,\n                error: 'Connection issue. Please try again.',\n                networkError: true\n            };\n        }\n    },\n\n    /**\n     * GET request\n     * @param {string} endpoint\n     * @returns {Promise}\n     */\n    async get(endpoint) {\n        return this.request(endpoint, { method: 'GET' });\n    },\n\n    /**\n     * POST request\n     * @param {string} endpoint\n     * @param {Object} body\n     * @returns {Promise}\n     */\n    async post(endpoint, body) {\n        return this.request(endpoint, {\n            method: 'POST',\n            body: JSON.stringify(body)\n        });\n    },\n\n    /**\n     * PUT request\n     * @param {string} endpoint\n     * @param {Object} body\n     * @returns {Promise}\n     */\n    async put(endpoint, body) {\n        return this.request(endpoint, {\n            method: 'PUT',\n            body: JSON.stringify(body)\n        });\n    },\n\n    /**\n     * DELETE request\n     * @param {string} endpoint\n     * @returns {Promise}\n     */\n    async delete(endpoint) {\n        return this.request(endpoint, { method: 'DELETE' });\n    },\n\n    // Convenience methods for common endpoints\n\n    /**\n     * Get all products\n     */\n    async getProducts() {\n        return this.get('/api/products');\n    },\n\n    /**\n     * Get all customers\n     */\n    async getCustomers() {\n        return this.get('/api/customers');\n    },\n\n    /**\n     * Get orders with optional filters\n     * @param {Object} filters - { status, paymentStatus, limit }\n     */\n    async getOrders(filters = {}) {\n        const params = new URLSearchParams(filters).toString();\n        return this.get(`/api/orders${params ? '?' + params : ''}`);\n    },\n\n    /**\n     * Get market rates\n     */\n    async getMarketRates() {\n        return this.get('/api/market-rates');\n    },\n\n    /**\n     * Get supplier quantity summary\n     */\n    async getQuantitySummary() {\n        return this.get('/api/supplier/quantity-summary');\n    },\n\n    /**\n     * Create a new order\n     * @param {Object} orderData\n     */\n    async createOrder(orderData) {\n        return this.post('/api/orders', orderData);\n    },\n\n    /**\n     * Update order status\n     * @param {string} orderId\n     * @param {string} status\n     */\n    async updateOrderStatus(orderId, status) {\n        return this.put(`/api/orders/${orderId}/status`, { status });\n    },\n\n    /**\n     * Update market rate\n     * @param {Object} rateData\n     */\n    async updateMarketRate(rateData) {\n        return this.post('/api/market-rates', rateData);\n    }\n};\n\n// Offline/Online event handlers\nwindow.addEventListener('online', () => {\n    console.log('Connection restored');\n    showSuccess('Connection restored');\n});\n\nwindow.addEventListener('offline', () => {\n    console.log('Connection lost');\n    showToast('No internet connection', 'info');\n});\n\n/**\n * Lightweight fetch wrapper with timeout + 401 redirect.\n * Drop-in replacement for fetch() in page scripts that use raw fetch.\n * Returns the Response object (same as fetch), or null on 401 redirect.\n */\nexport async function fetchWithAuth(url, options = {}) {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 15000);\n    try {\n        const res = await fetch(url, {\n            ...options,\n            credentials: 'include',\n            signal: controller.signal\n        });\n        if (res.status === 401) {\n            if (!API._redirecting401) {\n                API._redirecting401 = true;\n                window.location.href = '/pages/auth/login.html';\n            }\n            return null;\n        }\n        return res;\n    } catch (error) {\n        if (error.name === 'AbortError') {\n            throw new Error('Request timed out');\n        }\n        throw error;\n    } finally {\n        clearTimeout(timeout);\n    }\n}\n\n// Export for use in other modules\nexport default API;\n"],"file":"api-BDW4zv3H.js"}