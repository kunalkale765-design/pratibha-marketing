<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orders - Pratibha Marketing</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2e3532">

    <!-- Shared CSS -->
    <link rel="stylesheet" href="/css/variables.css">
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/components.css">
    <link rel="stylesheet" href="/css/utilities.css">
    <link rel="stylesheet" href="/css/responsive.css">

    <!-- Animations -->
    <link rel="stylesheet" href="/css/animations/skeleton.css">
    <link rel="stylesheet" href="/css/animations/cards.css">
    <link rel="stylesheet" href="/css/animations/inputs.css">
    <link rel="stylesheet" href="/css/animations/buttons.css">
    <link rel="stylesheet" href="/css/animations/badges.css">
    <link rel="stylesheet" href="/css/animations/segments.css">
    <link rel="stylesheet" href="/css/animations/page.css">
    <link rel="stylesheet" href="/css/animations/swipe.css">

    <!-- Page-specific styles -->
    <link rel="stylesheet" href="/css/pages/orders.css">
</head>
<body>
    <header class="header header-animated">
        <div class="header-content">
            <a href="/" class="logo">Pratibha <span>Marketing</span></a>
            <div class="header-btns">
                <a href="/customer-order-form.html" class="btn-header primary">+ New</a>
                <a href="/" class="btn-header">Home</a>
            </div>
        </div>
    </header>

    <div class="filters-bar" id="filtersBar">
        <div class="segment-control" id="filterSegments">
            <div class="segment-indicator" id="segmentIndicator"></div>
            <button class="segment-btn active" data-filter="all">All</button>
            <button class="segment-btn" data-filter="pending">Pending</button>
            <button class="segment-btn" data-filter="delivered">Delivered</button>
            <button class="segment-btn" data-filter="cancelled">Cancelled</button>
        </div>
    </div>

    <div class="search-bar">
        <input type="text" class="search-input input-animated" placeholder="Search order or customer..." id="searchInput">
    </div>

    <div id="toast" class="toast"></div>

    <div class="orders-list" id="ordersList">
        <!-- Skeleton loading placeholders -->
        <div class="skeleton-card" style="display: flex; align-items: center; gap: 0.875rem;">
            <div class="skeleton" style="width: 48px; height: 48px; border-radius: 12px; flex-shrink: 0;"></div>
            <div style="flex: 1;">
                <div class="skeleton skeleton-text" style="width: 60%; margin-bottom: 0.375rem;"></div>
                <div class="skeleton skeleton-text" style="width: 35%;"></div>
            </div>
            <div class="skeleton" style="width: 70px; height: 32px; border-radius: 20px;"></div>
        </div>
        <div class="skeleton-card" style="display: flex; align-items: center; gap: 0.875rem;">
            <div class="skeleton" style="width: 48px; height: 48px; border-radius: 12px; flex-shrink: 0;"></div>
            <div style="flex: 1;">
                <div class="skeleton skeleton-text" style="width: 70%; margin-bottom: 0.375rem;"></div>
                <div class="skeleton skeleton-text" style="width: 40%;"></div>
            </div>
            <div class="skeleton" style="width: 65px; height: 32px; border-radius: 20px;"></div>
        </div>
        <div class="skeleton-card" style="display: flex; align-items: center; gap: 0.875rem;">
            <div class="skeleton" style="width: 48px; height: 48px; border-radius: 12px; flex-shrink: 0;"></div>
            <div style="flex: 1;">
                <div class="skeleton skeleton-text" style="width: 55%; margin-bottom: 0.375rem;"></div>
                <div class="skeleton skeleton-text" style="width: 30%;"></div>
            </div>
            <div class="skeleton" style="width: 75px; height: 32px; border-radius: 20px;"></div>
        </div>
    </div>

    <!-- Order Detail Modal -->
    <div id="orderModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="modalTitle">Order Details</div>
                <button class="btn-close" onclick="closeModal()">×</button>
            </div>
            <div class="modal-body" id="modalBody"></div>
            <div class="modal-footer" id="modalFooter">
                <button class="btn-modal secondary btn-animated" id="printFromModalBtn" onclick="printFromModal()">
                    <span class="btn-text">Print Invoice</span>
                </button>
                <button class="btn-save-prices btn-animated" id="savePricesBtn" onclick="savePrices()">
                    <span class="btn-text">Save Changes</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Invoice Modal -->
    <div id="invoiceModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="invoiceModalTitle">Generate Invoice</div>
                <button class="btn-close" onclick="closeInvoiceModal()">×</button>
            </div>
            <div class="modal-body" id="invoiceModalBody">
                <div class="invoice-loading">Loading...</div>
            </div>
            <div class="modal-footer">
                <button class="btn-modal primary btn-animated" id="generateInvoiceBtn" onclick="generateInvoice()" disabled>
                    <span class="btn-text">Download PDF</span>
                </button>
            </div>
        </div>
    </div>

    <script type="module" src="/js/auth.js"></script>
    <script type="module" src="/js/api.js"></script>
    <script type="module">
        import { escapeHtml } from '/js/utils.js';
        import { showToast } from '/js/ui.js';

        // Wait for Auth to be available
        const waitForAuth = () => new Promise((resolve) => {
            if (window.Auth) resolve(window.Auth);
            else setTimeout(() => resolve(waitForAuth()), 10);
        });
        const Auth = await waitForAuth();

        let orders = [];
        let marketRates = {};
        let currentFilter = 'all';
        let currentOrderId = null;
        let currentOrder = null;
        let currentUser = null;
        let priceChanges = {};
        let quantityChanges = {};
        let isSaving = false; // Prevent concurrent saves

        // Track if global listeners have been initialized (prevents memory leak)
        let globalListenersInitialized = false;

        async function init() {
            currentUser = await Auth.requireAuth();
            if (!currentUser) return;

            // Hide status controls for customers
            if (currentUser.role === 'customer') {
                document.getElementById('modalFooter').style.display = 'none';
            }

            // Initialize global event listeners ONCE
            initGlobalListeners();

            await Promise.all([loadOrders(), loadMarketRates()]);
            setupFilters();
            setupSearch();
        }

        // Initialize listeners that should only be added once (not per render)
        function initGlobalListeners() {
            if (globalListenersInitialized) return;
            globalListenersInitialized = true;

            const container = document.getElementById('ordersList');

            // Close swipe items when tapping elsewhere (ONCE, not per render)
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.swipe-item')) {
                    document.querySelectorAll('.swipe-item.swiped, .swipe-item.swiped-single').forEach(item => {
                        item.classList.remove('swiped', 'swiped-single');
                    });
                }
            });

            // Delegated touch handling for swipe gestures
            let touchState = { startX: 0, isDragging: false, currentItem: null };

            container.addEventListener('touchstart', (e) => {
                const swipeItem = e.target.closest('.swipe-item');
                if (!swipeItem) return;

                touchState = {
                    startX: e.touches[0].clientX,
                    isDragging: true,
                    currentItem: swipeItem
                };

                // Close other open swipe items
                document.querySelectorAll('.swipe-item.swiped, .swipe-item.swiped-single').forEach(item => {
                    if (item !== swipeItem) {
                        item.classList.remove('swiped', 'swiped-single');
                    }
                });
            }, { passive: true });

            container.addEventListener('touchmove', (e) => {
                if (!touchState.isDragging || !touchState.currentItem) return;

                const isAdmin = currentUser?.role === 'admin';
                const diff = touchState.startX - e.touches[0].clientX;

                if (diff > 50) {
                    touchState.currentItem.classList.remove('swiped-single', 'swiped');
                    touchState.currentItem.classList.add(isAdmin ? 'swiped' : 'swiped-single');
                } else if (diff < -20) {
                    touchState.currentItem.classList.remove('swiped', 'swiped-single');
                }
            }, { passive: true });

            container.addEventListener('touchend', () => {
                touchState.isDragging = false;
                touchState.currentItem = null;
            }, { passive: true });
        }

        async function loadMarketRates() {
            try {
                const res = await fetch('/api/market-rates', { credentials: 'include' });
                if (!res.ok) {
                    throw new Error(`Server returned ${res.status}`);
                }
                const data = await res.json();
                (data.data || []).forEach(r => {
                    const pid = typeof r.product === 'object' ? r.product._id : r.product;
                    marketRates[pid] = r.rate;
                });
            } catch (e) {
                // Silently fail - market rates are supplementary data
                console.error('Failed to load market rates:', e);
            }
        }

        async function loadOrders() {
            try {
                const res = await fetch('/api/orders?limit=100', { credentials: 'include' });
                if (!res.ok) {
                    throw new Error(`Server returned ${res.status}`);
                }
                const data = await res.json();
                if (!data.success) {
                    throw new Error(data.message || 'Orders temporarily unavailable');
                }
                orders = data.data || [];
                // Debug: Log any orders with missing or invalid IDs
                const invalidOrders = orders.filter(o => !o._id || !/^[a-f\d]{24}$/i.test(o._id));
                if (invalidOrders.length > 0) {
                    console.warn('Orders with invalid IDs:', invalidOrders.map(o => ({ orderNumber: o.orderNumber, _id: o._id })));
                }
                renderOrders();
            } catch (e) {
                console.error('Failed to load orders:', e);
                // Show retry UI if no orders loaded yet
                if (!orders || orders.length === 0) {
                    const container = document.getElementById('ordersList');
                    const errorMsg = !navigator.onLine ? 'No internet connection' : 'Orders not available';
                    container.innerHTML = `
                        <div class="empty-state">
                            <p>${errorMsg}</p>
                            <button onclick="loadOrders()"
                                style="margin-top: 1rem; padding: 0.5rem 1rem; background: var(--dusty-olive); color: white; border: none; border-radius: 8px; cursor: pointer;">
                                Try Again
                            </button>
                        </div>
                    `;
                }
                // If we have stale data, just log the error silently
            }
        }

        function getInitials(name) {
            if (!name) return '?';
            const words = name.trim().split(/\s+/);
            if (words.length === 1) {
                return words[0].substring(0, 2).toUpperCase();
            }
            return (words[0][0] + words[words.length - 1][0]).toUpperCase();
        }

        function renderOrders() {
            const container = document.getElementById('ordersList');
            const search = document.getElementById('searchInput').value.toLowerCase();
            const isAdmin = currentUser?.role === 'admin';
            const isStaff = currentUser?.role === 'admin' || currentUser?.role === 'staff';

            // Filter out orders without valid _id first
            let filtered = orders.filter(o => o._id && /^[a-f\d]{24}$/i.test(o._id));

            // Filter by status
            if (currentFilter === 'all') {
                // "All" shows everything except cancelled (there's a dedicated Cancelled tab)
                filtered = filtered.filter(o => o.status !== 'cancelled');
            } else {
                filtered = filtered.filter(o => o.status === currentFilter);
            }

            // Filter by search
            if (search) {
                filtered = filtered.filter(o =>
                    o.orderNumber?.toLowerCase().includes(search) ||
                    o.customer?.name?.toLowerCase().includes(search)
                );
            }

            if (!filtered.length) {
                container.innerHTML = '<div class="empty-state">No orders found</div>';
                return;
            }

            container.innerHTML = filtered.map((o, idx) => `
                <div class="swipe-item card-fade-in" data-order-id="${escapeHtml(o._id)}" style="animation-delay: ${idx * 0.05}s">
                    <div class="swipe-content" onclick="viewOrder('${escapeHtml(o._id)}')">
                        <div class="order-avatar">${getInitials(o.customer?.name)}</div>
                        <div class="order-info">
                            <div class="order-customer">${escapeHtml(o.customer?.name || 'Unknown')}</div>
                            ${o.notes ? `<div class="order-notes">${escapeHtml(o.notes)}</div>` : ''}
                            <div class="order-number">Order #${escapeHtml(o.orderNumber)}</div>
                        </div>
                        <div class="order-amount-pill">₹${(o.totalAmount || 0).toLocaleString('en-IN')}</div>
                    </div>
                    <div class="swipe-actions">
                        ${isStaff ? `<button class="swipe-action edit" onclick="event.stopPropagation(); printOrder('${escapeHtml(o._id)}')">Print</button>` : ''}
                        ${isAdmin ? `<button class="swipe-action delete" onclick="event.stopPropagation(); deleteOrder('${escapeHtml(o._id)}')">Delete</button>` : ''}
                    </div>
                </div>
            `).join('');
            // Swipe handlers are now initialized once in initGlobalListeners() using event delegation
        }

        function setupFilters() {
            const segmentControl = document.getElementById('filterSegments');
            const indicator = document.getElementById('segmentIndicator');
            const buttons = segmentControl.querySelectorAll('.segment-btn');

            // Function to move indicator to a button
            function moveIndicator(btn) {
                const controlRect = segmentControl.getBoundingClientRect();
                const btnRect = btn.getBoundingClientRect();

                // Calculate position relative to the segment control
                const left = btnRect.left - controlRect.left;
                const width = btnRect.width;

                indicator.style.left = left + 'px';
                indicator.style.width = width + 'px';
            }

            // Initialize indicator position
            const activeBtn = segmentControl.querySelector('.segment-btn.active');
            if (activeBtn) {
                // Small delay to ensure layout is complete
                setTimeout(() => moveIndicator(activeBtn), 10);
            }

            // Handle clicks
            buttons.forEach(btn => {
                btn.onclick = () => {
                    // Update active state
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Slide the indicator
                    moveIndicator(btn);

                    // Update filter and re-render with animation
                    currentFilter = btn.dataset.filter;
                    const container = document.getElementById('ordersList');
                    container.classList.add('segment-content');
                    renderOrders();

                    // Remove animation class after it plays
                    setTimeout(() => container.classList.remove('segment-content'), 300);
                };
            });

            // Recalculate on window resize
            window.addEventListener('resize', () => {
                const active = segmentControl.querySelector('.segment-btn.active');
                if (active) moveIndicator(active);
            });
        }

        // Debounce utility to prevent excessive function calls
        function debounce(fn, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        function setupSearch() {
            const debouncedRender = debounce(renderOrders, 200);
            document.getElementById('searchInput').addEventListener('input', debouncedRender);
        }

        // NOTE: setupSwipeHandlers() was removed - swipe handling is now done via
        // event delegation in initGlobalListeners() to prevent memory leaks

        // Invoice state
        let invoiceData = null;
        let selectedFirmId = null;
        let selectedProductIds = new Set();

        async function printOrder(orderId) {
            // Only staff/admin can print invoices
            if (currentUser?.role === 'customer') {
                showToast('Invoice printing is not available', 'info');
                return;
            }

            // Close swipe
            document.querySelectorAll('.swipe-item.swiped, .swipe-item.swiped-single').forEach(item => {
                item.classList.remove('swiped', 'swiped-single');
            });

            // Validate order ID before proceeding
            const isValidMongoId = /^[a-f\d]{24}$/i.test(orderId);
            if (!orderId || !isValidMongoId) {
                console.error('Invalid order ID:', orderId);
                showToast('Order data updating. Please refresh.', 'info');
                return;
            }

            // Show invoice modal with loading
            document.getElementById('invoiceModal').classList.add('show');
            document.getElementById('invoiceModalBody').innerHTML = '<div class="invoice-loading">Loading invoice data...</div>';
            document.getElementById('generateInvoiceBtn').disabled = true;

            try {
                // Load firms list first
                await loadFirms();

                // Fetch split data from API
                const res = await fetch(`/api/invoices/${orderId}/split`, { credentials: 'include' });
                if (!res.ok) {
                    const errData = await res.json().catch(() => ({}));
                    throw new Error(errData.message || 'Invoice data temporarily unavailable');
                }
                const data = await res.json();
                invoiceData = data.data;

                // Set modal title
                document.getElementById('invoiceModalTitle').textContent = `Invoice for ${invoiceData.orderNumber}`;

                // Render firms and items
                renderInvoiceModal();
            } catch (error) {
                console.error('Print order error:', error);
                document.getElementById('invoiceModalBody').innerHTML = `
                    <div class="invoice-no-items">
                        <p>Invoice data not available</p>
                        <p style="font-size: 0.75rem; margin-top: 0.5rem;">${escapeHtml(error.message)}</p>
                    </div>
                `;
            }
        }

        // All available firms (fetched once)
        let allFirms = [];

        async function loadFirms() {
            if (allFirms.length > 0) return;
            try {
                const res = await fetch('/api/invoices/firms', { credentials: 'include' });
                if (res.ok) {
                    const data = await res.json();
                    allFirms = data.data || [];
                }
            } catch (e) {
                console.error('Failed to load firms:', e);
            }
        }

        function renderInvoiceModal() {
            if (!invoiceData) {
                document.getElementById('invoiceModalBody').innerHTML = '<div class="invoice-no-items">No items to invoice</div>';
                return;
            }

            // Get all items from all firms (flatten)
            const allItems = invoiceData.firms.flatMap(f => f.items);
            if (allItems.length === 0) {
                document.getElementById('invoiceModalBody').innerHTML = '<div class="invoice-no-items">No items to invoice</div>';
                return;
            }

            // Auto-select first firm and all items if none selected
            if (!selectedFirmId) {
                selectedFirmId = allFirms.length > 0 ? allFirms[0].id : (invoiceData?.firms?.[0]?.firmId || 'pratibha');
                selectedProductIds = new Set(allItems.map(i => i.productId));
            }

            // Calculate selected total
            const selectedTotal = allItems
                .filter(i => selectedProductIds.has(i.productId))
                .reduce((sum, i) => sum + (i.amount || 0), 0);

            // Build firm selector
            const firmsToShow = allFirms.length > 0 ? allFirms : (invoiceData?.firms || []).map(f => ({ id: f.firmId, name: f.firmName }));

            let html = `
                <div class="invoice-firm-selector">
                    <div class="info-label" style="margin-bottom: 0.5rem;">Select Firm</div>
                    <div class="firm-options">
                        ${firmsToShow.map(firm => `
                            <label class="firm-option ${selectedFirmId === firm.id ? 'selected' : ''}" onclick="selectFirm('${escapeHtml(firm.id)}')">
                                <input type="radio" name="firm" value="${escapeHtml(firm.id)}" ${selectedFirmId === firm.id ? 'checked' : ''}>
                                <span class="firm-option-name">${escapeHtml(firm.name)}</span>
                            </label>
                        `).join('')}
                    </div>
                </div>

                <div class="info-label" style="margin: 1rem 0 0.5rem;">Select Items</div>
                <div class="invoice-items-list">
                    ${allItems.map(item => `
                        <div class="invoice-item">
                            <input type="checkbox" class="invoice-item-checkbox"
                                data-product="${escapeHtml(item.productId)}"
                                ${selectedProductIds.has(item.productId) ? 'checked' : ''}
                                onchange="toggleInvoiceItem(null, '${escapeHtml(item.productId)}')">
                            <div class="invoice-item-details">
                                <div class="invoice-item-name">${escapeHtml(item.productName)}</div>
                                <div class="invoice-item-meta">${item.quantity || 0} ${escapeHtml(item.unit || '')} × ₹${(item.rate || 0).toLocaleString('en-IN')}</div>
                            </div>
                            <div class="invoice-item-amount">₹${(item.amount || 0).toLocaleString('en-IN')}</div>
                        </div>
                    `).join('')}
                </div>

                <div class="invoice-summary">
                    <div class="invoice-summary-label">Total</div>
                    <div class="invoice-summary-total">₹${selectedTotal.toLocaleString('en-IN')}</div>
                </div>
            `;

            document.getElementById('invoiceModalBody').innerHTML = html;
            document.getElementById('generateInvoiceBtn').disabled = selectedProductIds.size === 0;
        }

        function selectFirm(firmId) {
            selectedFirmId = firmId;
            renderInvoiceModal();
        }

        function toggleInvoiceItem(firmId, productId) {
            if (selectedProductIds.has(productId)) {
                selectedProductIds.delete(productId);
            } else {
                selectedProductIds.add(productId);
            }
            renderInvoiceModal();
        }

        async function generateInvoice() {
            // Button should already be disabled if no items selected
            if (!invoiceData || !selectedFirmId || selectedProductIds.size === 0) {
                return;
            }

            const btn = document.getElementById('generateInvoiceBtn');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            try {
                const headers = { 'Content-Type': 'application/json' };
                const csrfToken = await Auth.ensureCsrfToken();
                if (csrfToken) {
                    headers['X-CSRF-Token'] = csrfToken;
                }

                const res = await fetch(`/api/invoices/${invoiceData.orderId}/pdf`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({
                        firmId: selectedFirmId,
                        productIds: Array.from(selectedProductIds)
                    })
                });

                if (!res.ok) {
                    const errData = await res.json().catch(() => ({}));
                    throw new Error(errData.message || 'Invoice generation temporarily unavailable');
                }

                // Download the PDF
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `INV${invoiceData.orderNumber.replace('ORD', '')}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Invoice downloaded', 'success');
                closeInvoiceModal();
            } catch (error) {
                console.error('Generate invoice error:', error);
                showToast(error.message || 'Could not generate invoice', 'info');
            } finally {
                btn.classList.remove('btn-loading');
                btn.disabled = false;
            }
        }

        function closeInvoiceModal() {
            document.getElementById('invoiceModal').classList.remove('show');
            invoiceData = null;
            selectedFirmId = null;
            selectedProductIds = new Set();
        }

        function printFromModal() {
            // Silently return if no order - button shouldn't be clickable without an order
            if (!currentOrderId) {
                return;
            }
            // Save the ID before closeModal clears it
            const orderId = currentOrderId;
            closeModal(); // Close order detail modal (this sets currentOrderId = null)
            printOrder(orderId); // Open invoice modal with saved ID
        }

        async function deleteOrder(orderId) {
            // Admin check - button should be hidden for non-admins anyway
            if (currentUser?.role !== 'admin') {
                return;
            }

            if (!confirm('Are you sure you want to delete this order? This action cannot be undone.')) {
                return;
            }

            const item = document.querySelector(`.swipe-item[data-order-id="${orderId}"]`);

            try {
                const headers = { 'Content-Type': 'application/json' };
                const csrfToken = await Auth.ensureCsrfToken();
                if (csrfToken) {
                    headers['X-CSRF-Token'] = csrfToken;
                }

                const res = await fetch(`/api/orders/${orderId}`, {
                    method: 'DELETE',
                    headers,
                    credentials: 'include'
                });

                if (res.ok) {
                    // Add delete animation then reload orders
                    if (item) {
                        item.classList.add('deleting');
                        setTimeout(() => {
                            loadOrders(); // Reload from server
                        }, 300);
                    } else {
                        loadOrders(); // Reload from server
                    }
                    showToast('Order cancelled', 'success');
                } else {
                    const errData = await res.json().catch(() => ({ message: 'Could not cancel. Try again.' }));
                    showToast(errData.message || 'Could not cancel', 'info');
                }
            } catch (e) {
                console.error('Delete order error:', e);
                showToast('Could not delete order', 'info');
            }
        }

        async function viewOrder(id) {
            // Prevent opening new order while saving is in progress
            if (isSaving) {
                showToast('Please wait, saving in progress...', 'info');
                return;
            }

            try {
                const res = await fetch(`/api/orders/${id}`, { credentials: 'include' });

                // Handle non-JSON responses
                let data;
                try {
                    data = await res.json();
                } catch (parseError) {
                    console.error('Failed to parse order response:', parseError);
                    showToast('Server issue. Please refresh.', 'info');
                    return;
                }

                if (!res.ok) {
                    showToast(data?.message || 'Could not load order', 'info');
                    return;
                }

                const order = data.data;
                if (!order || !order.products) {
                    showToast('Order data updating. Refresh page.', 'info');
                    return;
                }

                currentOrderId = id;
                currentOrder = order;
                priceChanges = {};
                quantityChanges = {};
                document.getElementById('modalTitle').textContent = `#${order.orderNumber}`;
                document.getElementById('savePricesBtn').disabled = true;

                const isStaff = currentUser.role === 'admin' || currentUser.role === 'staff';

                const body = `
                    <div class="info-row">
                        <div>
                            <div class="info-label">Customer</div>
                            <div class="info-value">${escapeHtml(order.customer?.name)}</div>
                        </div>
                        <div>
                            <div class="info-label">Phone</div>
                            <div class="info-value">${escapeHtml(order.customer?.phone || '-')}</div>
                        </div>
                    </div>
                    <div class="info-row">
                        <div>
                            <div class="info-label">Date</div>
                            <div class="info-value">${new Date(order.createdAt).toLocaleDateString('en-IN')}</div>
                        </div>
                        <div>
                            <div class="info-label">Status</div>
                            <div class="info-value"><span class="badge badge-${escapeHtml(order.status)}">${escapeHtml(order.status)}</span></div>
                        </div>
                    </div>

                    <div class="info-section">
                        <div class="info-label">Products</div>
                        ${order.products.map((p, idx) => {
                            const productId = typeof p.product === 'object' ? p.product._id : p.product;
                            const purchasePrice = marketRates[productId] || p.rate || null;
                            const purchaseDisplay = purchasePrice ? `₹${purchasePrice.toLocaleString('en-IN')}` : 'N/A';
                            return `
                            <div class="product-item" data-idx="${idx}">
                                <div class="product-top">
                                    <div>
                                        <div class="product-name">${escapeHtml(p.productName)}</div>
                                        ${isStaff ? `
                                            <div class="qty-controls-inline">
                                                <button class="qty-btn-sm" onclick="changeQuantity(${idx}, -1)" type="button">−</button>
                                                <input type="number" class="qty-input-sm input-animated"
                                                    id="quantity-${idx}"
                                                    data-idx="${idx}"
                                                    data-original="${p.quantity}"
                                                    data-unit="${escapeHtml(p.unit)}"
                                                    value="${p.quantity}"
                                                    min="0" step="0.01"
                                                    onfocus="clearZero(this)"
                                                    onblur="restoreValue(this)"
                                                    onchange="handleQuantityChange(${idx})"
                                                    oninput="handleQuantityInput(${idx})">
                                                <button class="qty-btn-sm" onclick="changeQuantity(${idx}, 1)" type="button">+</button>
                                                <span class="qty-unit">${escapeHtml(p.unit)}</span>
                                            </div>
                                        ` : `<div class="product-qty">${p.quantity} ${escapeHtml(p.unit)}</div>`}
                                    </div>
                                </div>
                                <div class="prices-container">
                                    <div class="price-box">
                                        <div class="price-label">Purchase</div>
                                        <div class="price-value">${purchaseDisplay}</div>
                                    </div>
                                    <div class="price-box">
                                        <div class="price-label">Selling${p.isContractPrice ? ' <span class="contract-badge">Fixed</span>' : ''}</div>
                                        ${isStaff ? `
                                            <input type="number" class="price-input input-animated${p.isContractPrice ? ' contract-locked' : ''}"
                                                id="price-${idx}"
                                                data-idx="${idx}"
                                                data-original="${p.rate}"
                                                data-qty="${p.quantity}"
                                                data-contract="${p.isContractPrice || false}"
                                                value="${p.rate}"
                                                min="0" step="0.01"
                                                ${p.isContractPrice ? 'disabled title="Contract price - edit in customer management"' : ''}
                                                onfocus="clearZero(this)"
                                                onblur="restoreValue(this)"
                                                onchange="handlePriceChange(${idx})"
                                                oninput="handlePriceInput(${idx})">
                                        ` : `<div class="price-value">₹${p.rate}</div>`}
                                    </div>
                                </div>
                                <div class="amount-row">
                                    <span class="amount-label">Amount</span>
                                    <span class="amount-display" id="amount-${idx}">₹${p.amount}</span>
                                </div>
                            </div>
                        `}).join('')}
                    </div>

                    <div class="total-section">
                        <div class="total-row">
                            <span>Total</span>
                            <span id="orderTotal">₹${order.totalAmount}</span>
                        </div>
                        <div class="total-row">
                            <span>Paid</span>
                            <span>₹${order.paidAmount || 0}</span>
                        </div>
                        <div class="total-row main">
                            <span>Balance</span>
                            <span id="orderBalance">₹${order.totalAmount - (order.paidAmount || 0)}</span>
                        </div>
                    </div>
                `;

                document.getElementById('modalBody').innerHTML = body;
                document.getElementById('orderModal').classList.add('show');
            } catch (e) {
                showToast('Could not load order', 'info');
            }
        }

        function clearZero(input) {
            input.dataset.prevValue = input.value;
            input.value = '';
            input.select();
        }

        function restoreValue(input) {
            if (input.value === '') {
                input.value = input.dataset.prevValue || input.dataset.original;
            }
            const idx = parseInt(input.dataset.idx);
            handlePriceChange(idx);
        }

        function handlePriceInput(idx) {
            const input = document.getElementById(`price-${idx}`);
            const qtyInput = document.getElementById(`quantity-${idx}`);
            const original = parseFloat(input.dataset.original);
            const current = parseFloat(input.value) || 0;
            // Use quantity from input if exists, otherwise from data attribute
            const qty = qtyInput ? (parseFloat(qtyInput.value) || 0) : parseFloat(input.dataset.qty);

            input.classList.toggle('changed', current !== original);

            // Update amount display (round to 2 decimal places for consistency)
            const amount = Math.round(current * qty * 100) / 100;
            const amountEl = document.getElementById(`amount-${idx}`);
            if (amountEl) amountEl.textContent = `₹${amount.toLocaleString('en-IN')}`;

            // Update total
            updateOrderTotal();
        }

        function handlePriceChange(idx) {
            const input = document.getElementById(`price-${idx}`);
            if (!input) return;
            const original = parseFloat(input.dataset.original);
            const current = parseFloat(input.value) || 0;

            if (current !== original && current > 0) {
                priceChanges[idx] = current;
            } else {
                delete priceChanges[idx];
            }

            // Enable/disable save button (check BOTH price and quantity changes)
            const hasChanges = Object.keys(priceChanges).length > 0 || Object.keys(quantityChanges).length > 0;
            document.getElementById('savePricesBtn').disabled = !hasChanges;
        }

        // Quantity change handlers
        function changeQuantity(idx, delta) {
            const input = document.getElementById(`quantity-${idx}`);
            if (!input) return;

            const current = parseFloat(input.value) || 0;
            let newValue = current + delta;

            // Minimum quantity for all units
            const minQty = 0.2;

            // Snap to 0 if going below minimum (allows removal)
            if (newValue < minQty && newValue > 0) {
                newValue = 0;
            }

            // Don't go below 0
            if (newValue < 0) {
                newValue = 0;
            }

            input.value = newValue;
            handleQuantityChange(idx);
            handleQuantityInput(idx);
        }

        function handleQuantityInput(idx) {
            const qtyInput = document.getElementById(`quantity-${idx}`);
            const priceInput = document.getElementById(`price-${idx}`);
            if (!qtyInput) return;

            const originalQty = parseFloat(qtyInput.dataset.original);
            const currentQty = parseFloat(qtyInput.value) || 0;

            // Visual feedback for changed quantity
            qtyInput.classList.remove('changed', 'removed');
            if (currentQty === 0) {
                qtyInput.classList.add('removed');
            } else if (currentQty !== originalQty) {
                qtyInput.classList.add('changed');
            }

            // Get current rate (may be modified)
            const rate = priceInput ? (parseFloat(priceInput.value) || 0) : (currentOrder?.products[idx]?.rate || 0);

            // Recalculate amount
            const amount = Math.round(currentQty * rate * 100) / 100;
            const amountEl = document.getElementById(`amount-${idx}`);
            if (amountEl) amountEl.textContent = `₹${amount.toLocaleString('en-IN')}`;

            // Update total
            updateOrderTotal();
        }

        function handleQuantityChange(idx) {
            const input = document.getElementById(`quantity-${idx}`);
            if (!input) return;

            const original = parseFloat(input.dataset.original);
            const current = parseFloat(input.value) || 0;

            // Validate minimum quantity
            const minQty = 0.2;

            if (current > 0 && current < minQty) {
                showToast(`Minimum quantity: ${minQty} ${input.dataset.unit}`, 'info');
                input.value = original;
                delete quantityChanges[idx];
            } else if (current !== original) {
                quantityChanges[idx] = current;
            } else {
                delete quantityChanges[idx];
            }

            // Enable/disable save button (check BOTH price and quantity changes)
            const hasChanges = Object.keys(priceChanges).length > 0 || Object.keys(quantityChanges).length > 0;
            document.getElementById('savePricesBtn').disabled = !hasChanges;

            // Trigger amount recalculation
            handleQuantityInput(idx);
        }

        function updateOrderTotal() {
            if (!currentOrder || !currentOrder.products) return;

            let total = 0;
            currentOrder.products.forEach((p, idx) => {
                const priceInput = document.getElementById(`price-${idx}`);
                const qtyInput = document.getElementById(`quantity-${idx}`);
                const rate = priceInput ? (parseFloat(priceInput.value) || 0) : p.rate;
                const quantity = qtyInput ? (parseFloat(qtyInput.value) || 0) : p.quantity;
                total += rate * quantity;
            });

            // Round to 2 decimal places for consistency with backend
            total = Math.round(total * 100) / 100;
            const balance = Math.round((total - (currentOrder.paidAmount || 0)) * 100) / 100;

            const totalEl = document.getElementById('orderTotal');
            const balanceEl = document.getElementById('orderBalance');
            if (totalEl) totalEl.textContent = `₹${total.toLocaleString('en-IN')}`;
            if (balanceEl) balanceEl.textContent = `₹${balance.toLocaleString('en-IN')}`;
        }

        // Check if invoices exist for an order
        async function checkInvoicesExist(orderId) {
            try {
                const res = await fetch(`/api/invoices/order/${orderId}`, { credentials: 'include' });
                if (!res.ok) return false;
                const data = await res.json();
                return data.data && data.data.length > 0;
            } catch (e) {
                console.error('Failed to check invoices:', e);
                return false;
            }
        }

        async function savePrices() {
            // Check for BOTH price and quantity changes
            const hasChanges = Object.keys(priceChanges).length > 0 || Object.keys(quantityChanges).length > 0;
            if (!currentOrderId || !currentOrder || !currentOrder.products || !hasChanges) return;

            // Prevent concurrent saves
            if (isSaving) {
                showToast('Save in progress...', 'info');
                return;
            }

            isSaving = true;
            const btn = document.getElementById('savePricesBtn');
            btn.disabled = true;
            btn.classList.add('btn-loading');

            // Check if invoices exist
            let hasInvoices = false;
            try {
                hasInvoices = await checkInvoicesExist(currentOrderId);
                if (hasInvoices) {
                    const proceed = confirm(
                        'Invoices exist for this order. Changes will not update existing invoices.\n\n' +
                        'You may need to regenerate invoices after saving. Continue?'
                    );
                    if (!proceed) {
                        isSaving = false;
                        btn.classList.remove('btn-loading');
                        btn.disabled = false;
                        return;
                    }
                }
            } catch (e) {
                console.error('Invoice check failed:', e);
                // Continue anyway - don't block save
            }

            try {
                // Build updated products array with quantities
                const updatedProducts = currentOrder.products
                    .map((p, idx) => {
                        let price = priceChanges[idx] !== undefined ? priceChanges[idx] : p.rate;
                        let quantity = quantityChanges[idx] !== undefined ? quantityChanges[idx] : p.quantity;

                        // Safety checks
                        if (!price || price <= 0) price = p.rate;
                        if (quantity < 0) quantity = p.quantity;

                        return {
                            product: typeof p.product === 'object' ? p.product._id : p.product,
                            quantity: quantity,
                            priceAtTime: price
                        };
                    })
                    .filter(item => item.quantity > 0); // Remove items with quantity = 0

                const headers = { 'Content-Type': 'application/json' };
                const csrfToken = await Auth.ensureCsrfToken();
                if (csrfToken) {
                    headers['X-CSRF-Token'] = csrfToken;
                }

                const payload = { products: updatedProducts };
                const orderId = currentOrderId; // Capture to avoid race conditions

                let res = await fetch(`/api/orders/${orderId}`, {
                    method: 'PUT',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify(payload)
                });

                // Handle CSRF error with single retry
                if (res.status === 403) {
                    let errData;
                    try {
                        errData = await res.json();
                    } catch {
                        errData = { message: 'Access denied' };
                    }

                    if (errData.message?.toLowerCase().includes('csrf')) {
                        const newToken = await Auth.refreshCsrfToken();
                        if (newToken) {
                            headers['X-CSRF-Token'] = newToken;
                            res = await fetch(`/api/orders/${orderId}`, {
                                method: 'PUT',
                                headers,
                                credentials: 'include',
                                body: JSON.stringify(payload)
                            });

                            // If retry also fails with CSRF, tell user to refresh
                            if (res.status === 403) {
                                let retryErr;
                                try {
                                    retryErr = await res.json();
                                } catch {
                                    retryErr = { message: '' };
                                }
                                if (retryErr.message?.toLowerCase().includes('csrf')) {
                                    showToast('Session expired. Please refresh the page.', 'info');
                                } else {
                                    showToast(retryErr.message || 'Access denied', 'info');
                                }
                                isSaving = false;
                                btn.classList.remove('btn-loading');
                                btn.disabled = false;
                                return;
                            }
                        } else {
                            showToast('Session expired. Please refresh the page.', 'info');
                            isSaving = false;
                            btn.classList.remove('btn-loading');
                            btn.disabled = false;
                            return;
                        }
                    } else {
                        showToast(errData.message || 'Access temporarily unavailable', 'info');
                        isSaving = false;
                        btn.classList.remove('btn-loading');
                        btn.disabled = false;
                        return;
                    }
                }

                if (res.ok) {
                    showToast('Changes saved', 'success');
                    priceChanges = {};
                    quantityChanges = {};
                    btn.classList.remove('btn-loading');
                    btn.classList.add('btn-success');
                    setTimeout(() => btn.classList.remove('btn-success'), 1500);
                    btn.disabled = true;
                    loadOrders();

                    // Prompt to regenerate invoice if needed
                    if (hasInvoices) {
                        setTimeout(() => {
                            if (confirm('Order updated. Regenerate invoice with new quantities?')) {
                                const orderIdToEdit = orderId; // Capture before modal closes
                                closeModal();
                                setTimeout(() => printOrder(orderIdToEdit), 300);
                            }
                        }, 500);
                    }

                    // Refresh the modal if still viewing same order
                    if (currentOrderId === orderId) {
                        viewOrder(orderId);
                    }
                } else {
                    let errData;
                    try {
                        errData = await res.json();
                    } catch {
                        errData = { message: `Server error (${res.status})` };
                    }
                    showToast(errData.message || 'Could not update', 'info');
                    btn.disabled = false;
                }
            } catch (e) {
                console.error('Save changes error:', e);
                if (!navigator.onLine) {
                    showToast('No internet connection', 'info');
                } else {
                    showToast('Could not save. Try again.', 'info');
                }
                btn.disabled = false;
            } finally {
                isSaving = false;
                btn.classList.remove('btn-loading');
            }
        }

        function closeModal() {
            // Warn about unsaved changes (price OR quantity)
            const hasChanges = Object.keys(priceChanges).length > 0 || Object.keys(quantityChanges).length > 0;
            if (hasChanges) {
                if (!confirm('You have unsaved changes. Discard them?')) {
                    return;
                }
            }
            document.getElementById('orderModal').classList.remove('show');
            currentOrderId = null;
            currentOrder = null;
            priceChanges = {};
            quantityChanges = {};
        }
        // Expose to window for onclick handlers
        window.closeModal = closeModal;
        window.viewOrder = viewOrder;
        window.clearZero = clearZero;
        window.restoreValue = restoreValue;
        window.handlePriceChange = handlePriceChange;
        window.handlePriceInput = handlePriceInput;
        window.handleQuantityChange = handleQuantityChange;
        window.handleQuantityInput = handleQuantityInput;
        window.changeQuantity = changeQuantity;
        window.savePrices = savePrices;
        window.deleteOrder = deleteOrder;
        window.printOrder = printOrder;
        // Invoice modal functions
        window.closeInvoiceModal = closeInvoiceModal;
        window.selectFirm = selectFirm;
        window.toggleInvoiceItem = toggleInvoiceItem;
        window.generateInvoice = generateInvoice;
        window.printFromModal = printFromModal;

        // Close modal on overlay click
        document.getElementById('orderModal').onclick = (e) => {
            if (e.target.id === 'orderModal') closeModal();
        };

        // Close invoice modal on overlay click
        document.getElementById('invoiceModal').onclick = (e) => {
            if (e.target.id === 'invoiceModal') closeInvoiceModal();
        };

        init();
    </script>
</body>
</html>
